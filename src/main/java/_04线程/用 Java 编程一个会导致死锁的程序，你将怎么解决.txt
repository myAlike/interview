6）用 Java 编程一个会导致死锁的程序，你将怎么解决？

这是我最喜欢的 Java 线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，
但是很多侯选者并不能写 deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们， 你有 N 个资源和 N 个线程，并且你需要所有的资源来完成一个操作。为了简单这里的 n 可 以替换为 2，越大的数据会使问题看起来更复杂。通过避免 Java 中的死锁来得到关于死锁的 更多信息。


第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么 一回事儿：线程 A 和线程 B 相互等待对方持有的锁导致程序无限死循环下去。 当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白 了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本 上是看不出来的。
真正理解什么是死锁，这个问题其实不难，几个步骤： 1）两个线程里面分别持有两个 Object 对象：lock1 和 lock2。这两个 lock 作为同步代码块的锁；
2 ） 线 程 1 的 run() 方 法 中 同 步 代 码 块 先 获 取 lock1 的 对 象 锁 ， Thread.sleep(xxx)，时间不需要太多，50 毫秒差不多了，然后接着获取 lock2 的对象锁。这么做主要是为了防止线程 1 启动一下子就连续获得了 lock1 和 lock2 两个对象的对象锁
3）线程 2 的 run)(方法中同步代码块先获取 lock2 的对象锁，接着获取 lock1 的对象锁，当然这时 lock1 的对象锁已经被线程 1 锁持有，线程 2 肯定是要 等待线程 1 释放 lock1 的对象锁的
这样，线程 1"睡觉"睡完，线程 2 已经获取了 lock2 的对象锁了，线程 1 此时 尝试获取 lock2 的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，

占的篇幅有点多，Java 多线程 7：死锁这篇文章里面有，就是上面步骤的代 码实现。
点击这里提供了一个死锁的案例。